[{"title":"金字塔内部的结构","url":"/2018/08/14/金字塔内部的结构/","content":"\n有些显而易见的事实可能也需要经过很长时间才能被人们所认识。\n\n## 纵向关系\n\n> 一般的文档都是一维的：一个句子接着一个句子，呈现出纵向向下的结构。\n\n这种纵向延伸掩盖了一个事实，即思想是位于不同的抽象层次上的，大主题下的任何思想都同时与文中的其他思想发生着纵向及横向的关系。\n\n纵向联系能够很好的吸引读者的注意力。通过纵向联系，你可以引导一种疑问/问答式的对话，从而使读者带着极大兴趣了解你的思路进展。这种纵向联系会迫使读者按照你的思路产生符合逻辑的反应。\n\n向受众传递新信息的同时，必然会引发对方就其逻辑产生新的疑问，作为作者，你必须在该表述的下一个层次上横向地回答读者的疑问，甚至进行几轮递归。\n\n要想吸引读者的全部注意力，作者必须在做好回答问题的准备之前避免引起读者的疑问。\n\n\n## 横向关系\n当你考虑在下一个结构层次上如何表述时，必须保证你的表述可以回答上一个层次表述的疑问，同时还必须保证表述符合逻辑。\n\n> 表述必须具有明确的归纳或者演绎关系，但不可同时既具有归纳关系，又具有演绎关系。\n\n在组织思想时，归纳和演绎是仅有的两种可能的逻辑关系。\n\n\n\n## 序言的结构\n\n序言是引导读者进入作者设定的疑问/回答式对话的必要条件。\n\n问题的起源和发展必然以叙述的形式出现，因此也应当按照典型的叙述模式发展。序言的开头应当向读者说明“背景”的时间和地点。在这一背景中应当发生了某件事情，可称为“冲突”，使读者提出你的文章将要“回答”的“疑问”。\n\n> 背景、冲突、疑问、回答。\n\n\n\n","tags":["软素质"]},{"title":"为什么要使用金字塔结构","url":"/2018/08/12/为什么要使用金字塔结构/","content":"\n人类思维的基本规律\n\n```\n· 大脑自动将信息归纳到金字塔结构的各组中，以便于理解和记忆\n\n· 预先归纳到金子塔中的沟通内容，都更容易被人理解和记忆\n\n· 你应该有意识地将沟通内容组织成金字塔结构，包括口头表达和书面表达——说话、培训、演讲、报告、述职和文章、总结、申请方案、计划等\n\n```\n\n\n## 归类分组，将思想组织成金字塔\n\n### 奇妙的数字“7”\n\n人的短时记忆中，能够记住的对象，符合“7+/-2”原则，很多人能一次记住7个对象，有的人能一次记住9个对象，而有的智能记住5个。\n\n意味着，当大脑发现需要处理的项目超过4个或者5个时，就会开始将其归类到不同的逻辑范畴中，以便于记忆。\n\n### 归类分组搭建金字塔\n\n试想想你的妻子（前提得要先有一位妻子）让你去买烟的时候顺便带一些食品回来，口头给出了一个清单：\n\n```\n葡萄、橘子、牛奶、咸鸭蛋、土豆、苹果、鸡蛋、酸奶、胡萝卜\n```\n\n仅仅是想出去买包烟，结果多了一个清单，怎么才能记住呢？\n\n按金字塔原理来思考，可以根据清单内食品的属性进行归类：\n\n* 鸡蛋牛奶制品：牛奶、咸鸭蛋、鸡蛋、酸奶\n* 水果：葡萄、橘子、苹果\n* 蔬菜: 土豆、胡萝卜\n\n这样下来，记忆起来会轻松不少，因为虽然还是9个食品清单，但是分组后的记忆会轻松不少，因为不仅仅是分组，还有提高了一个抽象层次，即将有一定逻辑关系的食品抽象出一个新的概念。\n\n```\n由于处于较高层次的思想总是能够提示下一个层次的思想，而且这种关系比较自然，因而也更容易记住。\n```\n\n\n## 自上而下表达，结论先行\n\n先提出总结性思想，再提出被总结的具体思想。\n\n\n受众的大脑只能逐字理解作者的表达的思想。他们会假定一同出现的思想在逻辑上存在某种关系。如果你不预先告诉他们这种逻辑关系，而是一句一句地表达你的意思，读者就会自动从中寻找共同点，将你所表达的思想归类组合，以便了解各个组合的意义。\n\n\n## 自下而上思考，总结概括\n\n金字塔中的思想以3种方式互相关联——向上、向下、横向。位于一组思想的上一个层次是对这一组思想的概括，这一组思想则是对其上一层的解释和支持。\n\n* 纵向：文章中的任意一层的思想必须是下一层思想的概括\n* 横向：每组中的思想必须属于同一逻辑范畴\n* 横向：每组中的思想必须按逻辑顺序组织\n\n\n\n\n\n\n\n\n\n\n","tags":["软素质"]},{"title":"金字塔原理概述","url":"/2018/08/12/金字塔原理概述/","content":"## 基本原理\n\n一种重点突出、逻辑清晰、层次分明、简单易懂的思考方式、沟通方式、规范动作\n\n## 基本结构\n\n结论先行，以上统下，归类分组，逻辑递进。\n先重要后次要，先总结后具体，先框架后细节，先结论后原因，先结果会后过程，先论点后论据。\n\n\n## 训练表达者\n挖掘受众意图、关注点、利益点、兴趣点，想清楚说什么（内容），怎么说（思路，结构），掌握沟通的标准结构和规范动作\n\n\n## 解决的问题\n\n### 思考\n\n学会左、右脑全脑思考，提高结构化思考能力，做到全、准、快\n\n\n### 书面表达，公文写作\n\n会挖掘读者的关注点、兴趣点、需求点、利益点，能使用金字塔原理的4个原则，搭建逻辑清晰的常用公文写作框架，掌握写序言的四要素，归类分组的MECE原则，能够做到重点突出、逻辑清晰、简明扼要，让人看得懂、愿意看、记得住。快速写文章，缩短写作时间，减少修改次数。\n\n```\n紧急的写作（方案）任务往往没有足够的时间让你反复琢磨结构，修改内容，学习金字塔原理，掌握各种文档的写作结构（其实是对各种场景成功文案的总结）和问题拆分方法，可以达到快速成文，而且质量还不错的效果。\n```\n\n\n### 口头表达\n\n说话、演讲、讲课，能够使用金字塔原理的基本原则，回答受众最常用的四类问题：“是什么？为什么？如何做？好不好？”表达时重点突出、条理清晰，让人愿意听、听得懂、记得住，成为思路清晰，言简意赅的人。\n\n```\n良好的口头表达就是节约对话双方的时间，间接地在珍惜生命。\n```\n\n\n\n### 管理下属\n\n能够运用金字塔原理，考虑全面、周到、严谨，分配任务、设计流程不重不漏。\n\n```\n全面考虑问题（需求）、分析问题、设计解决方案、拆分工作，非常重要，直接影响到管理者的工作效率和下属的绩效。\n```\n\n\n### 培训师开发课程和讲课\n\n学会使用金字塔原理搭建框架结构、组织素材、重点突出、逻辑清晰、通俗易懂。\n\n```\n从一篇文档，一段对话，到一门课程，涉及的内容量通常会原来越大，组织的难度也越来越高，但是遵循的基本原理可以是一致的，即金字塔原理。每一门课程都有一个中心主题（即课程的核心主题），中心主题之下又有多个分主题（通常对应课程的不同阶段应该掌握的内容，按难易程度或者内容的承接性自然有序），不同阶段应该学习的内容也可以进行分级（可以分配必须掌握和选修）...以此方式进行深入的思考和划分设计出来的课程，自然是比较容易学习的。\n```\n\n\n\n\n","tags":["软素质"]},{"title":"CORS-跨域请求资源的协议","url":"/2018/06/09/CORS-跨域请求资源协议/","content":"\n当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。\n\n出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS协议请求资源。\n\n# 什么是CORS\n\nCORS（Cross-Origin Resource Sharing 跨源资源共享），当一个请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。\n\n[Web应用安全模型](https://en.wikipedia.org/wiki/Same-origin_policy)，浏览器默认的默认模型，即同源策略，运行在web浏览器下的脚本（如JavaScript），\n可以访问同一个域下的其他页面（资源）下的数据，但是禁止访问其他域下的资源数据。这种限制对于依赖cookie、session等信息的安全认证机制十分重要，减轻跨站信息泄露风险。\n但是随着Web应用的发展，不同域下的资源共享需求越来越大。为了突破同源策略，一种解决方案是[JSONP](https://www.cnblogs.com/JerryTian/p/4194900.html)，可以说是中针对dom加载机制的hack技术，有较大的风险，而CORS是W3C提出的一种解决跨域资源共享的标准化协议，目前主流浏览器都支持该协议。\n\nCORS新增了一组Http首部字段，允许声明哪些源站有权限访问资源，使得跨站数据传输更安全，减少http跨域的风险。\n\n\n# CORS的作用\n\n为了改善网络应用程序，开发人员要求浏览器供应商允许跨域请求。跨域请求主要用于：\n\n- 调用XMLHttpRequest或fetchAPI通过跨站点方式访问资源\n- 网络字体，例如Bootstrap（通过CSS使用@font-face 跨域调用字体）\n- 通过canvas标签，绘制图表和视频\n\n\n# 客户端的处理\n\n## 简单跨域\n当请求同时满足下面两个条件时，浏览器会直接发送GET请求，在同一个请求中做跨域权限的验证。\n\n请求方法是下列之一：\n\n- GET\n- HEAD\n- POST\n\n请求头中的Content-Type请求头的值是下列之一：\n\n- application/x-www-form-urlencoded\n- multipart/form-data\n- text/plain\n\n简单请求时，浏览器会直接发送跨域请求，并在请求头中携带Origin 的header，表明这是一个跨域的请求。服务器端接到请求后，\n会根据自己的跨域规则，通过Access-Control-Allow-Origin和Access-Control-Allow-Methods响应头，来返回验证结果。\n如果验证成功，则会直接返回访问的资源内容。\n\n\n## 预检请求\n与前述简单跨域请求不同，“需预检的请求”要求必须首先使用`OPTIONS`方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。\"预检请求“的使用，\n可以避免跨域请求对服务器的用户数据产生未预期的影响。\n\n\nOPTIONS请求头部中会包含以下头部：`Origin`、`Access-Control-Request-Method`、`Access-Control-Request-Headers`。\n服务器收到`OPTIONS`请求后，设置`Access-Control-Allow-Origin`、`Access-Control-Allow-Methods`、`Access-Control-Allow-Headers`头部与浏览器沟通来判断是否允许这个请求。\n如果Preflighted requests验证通过，浏览器才会发送真正的跨域请求。\n\n\n# CORS增加的首部字段\n\n## Request Header\n\n<pre>\norigin\n</pre>\n\n\nOrigin头在跨域请求或预先请求中，标明发起跨域请求的源域名。\n\n<pre>\nAccess-Control-Request-Method\n</pre>\n\n\n用于表明跨域请求使用的实际HTTP方法\n\n\n<pre>\nAccess-Control-Request-Headers\n</pre>\n\n\n用于在预先请求时，告知服务器要发起的跨域请求中会携带的请求头信息\n\n\n## Response Header\n\n<pre>\nAccess-Control-Allow-Origin\n</pre>\n\n\n\n 服务器端验证后的允许的跨域请求域名，可以是一个具体的域名或是一个*。\n\n<pre>\nAccess-Control-Expose-Headers\n</pre>\n\n\n用于允许返回给跨域请求的响应头列表，在列表中的响应头的内容，才可以被浏览器访问。\n\n<pre>\nAccess-Control-Max-Age\n</pre>\n\n\n用于告知浏览器可以将预先检查请求返回结果缓存的时间，在缓存有效期内，浏览器会使用缓存的预先检查结果判断是否发送跨域请求。\n\n\n<pre>\nAccess-Control-Allow-Credentials\n</pre>\n\n \n用于告知浏览器当withCredentials属性设置为true时，是否可以显示跨域请求返回的内容。简单请求时，浏览器会根据此响应头决定是否显示响应的内容。预先验证请求时，浏览器会根据此响应头决定在发送实际跨域请求时，是否携带认证信息。\n\n<pre>\nAccess-Control-Allow-Methods\n</pre>\n\n 用于告知浏览器可以在实际发送跨域请求时，可以支持的请求方法，可以是一个具体的方法列表或是一个*（表示任意方法）\n\n<pre>\nAccess-Control-Allow-Headers\n</pre>\n\n用于告知浏览器可以在实际发送跨域请求时，可以支持的请求头，可以是一个具体的请求头列表或是一个*（表示任意请求头）\n\n\n# 基于CORS的CSRF攻击\n\nCSRF攻击的大致原理：\n\n+ 用户通过浏览器，访问正常网站A（例如交易平台），通过用户的身份认证（比如用户名/密码）成功；\n+ 网站A产生token等Cookie信息并返回到用户浏览器； \n+ 用户保持A网站页面登录状态的情况下，在同一浏览器中，打开一个新的TAB页访问恶意网站B；\n+ 网站B接收到用户请求后，返回一些攻击性代码，请求A网站的资源（比如发起交易）；\n+ 浏览器执行恶意代码，在用户不知情的情况下携带Cookie信息，向网站A发出请求；\n- 网站A根据用户的Cookie信息核实用户身份（此时用户在A网站是已登录状态），A网站会处理该请求，导致来自网站B的恶意请求被执行；\n\n当然，一般涉及到钱的网站都会有安全审计检查，这种漏洞几乎是不存在的。\n\n\n\n\n# 参考资料\n+ [CORS](https://www.w3.org/TR/cors/)\n+ [enable-cors](https://enable-cors.org/)\n+ [用XMLHTTPRequest来进行ajax异步数据交交互](https://blog.csdn.net/z_l_ming/article/details/54969019)\n- [HTTP访问控制（CORS）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)","tags":["HTTP协议"]},{"title":"MySQL体系结构和存储引擎","url":"/2017/11/08/MySQL体系结构和存储引擎/","content":"## 数据库和实例\n这是两个比较容易混淆的概念：\n\n- 数据库：物理操作系统文件或其他形式文件类型的集合\n- 实例：MySQL数据库有后台线程及一个共享区组成\n\n在MySQL数据库中，这两者的关系通常是一一对应的，即一个数据库对应一个实例，但是在集群情况下，会存在多个实例对应一个数据库的情况。\n\nMySQL是一个被设计为单进程多线程的数据库。MySQL在启动的时候会按一定的顺序查找配置文件， 在存在多份配置文件的时候<!-- more -->，后加载的配置会覆盖先加载的配置；如果没有找到配置文件，则会按照编译时的默认参数设置启动实例。配置搜索顺序可以通过下面的方式查询：\n\n```\ngary@x1:~$ mysql --help | grep my.cnf\n                      order of preference, my.cnf, $MYSQL_TCP_PORT,\n/etc/my.cnf /etc/mysql/my.cnf ~/.my.cnf \n```\n\n## MySQL体系结构\n在学习MySQL体系结构之前，再次辨识下数据库和实例的概念。从概念上说，数据库是文件的概念，是依照某种数据模型组织起来的并存放于二级存储器中的数据集合；数据库实例是程序，是位于用户与操作系统之间的一层数据管理软件，用户对于数据库数据的任何操作，包括数据库定义、数据查询、数据库运行控制等都是在数据实例下进。\n\n![]()\n\n数据库主要由连接池组件、管理和工具组件、SQL接口组件、查询分析器组件、优化器组件、缓冲组件、插件式存储引擎、物理文件。\n\n存储引擎是基于表，而非数据库。\n\n\n## MySQL存储引擎\nMySQL插件式的存储引擎体系结构是它区别于其他数据库的一个重要方面，下面介绍下集中常见的存储引擎。\n\n### InnoDB存储引擎\nInnoDB存储引擎支持事务，设计目标主要面向于`在线事务处理`（OLTP）应用，其主要特点是行锁设计、支持外键。InnoDB存储引擎将数据放在一个逻辑的表空间中，由InnoDB自行管理。从MySQL4.1起，它可以通过一个个独立的ibd文件隔离每个InnoDB存储引擎的表，也支持使用裸设备来建立其表空间。\n\nInnoDB通过`多版本并发控制`(MVCC)来获得高并发行，并且实现了SQL标准的4种`隔离级别`，默认为可重复读(REPEATABLE)。同时使用next-key locking的策略来避免`幻读`现象的产生。\n\nInnoDB存储引擎采用了`聚集`(clustered)的方式来存储表中的数据，每张表的存储都是按主键的顺序进行存放。如果没有显式定义主键，存储引会为每一行生成一个6字节的ROWID，并以此为主键。\n\n\n### MyISAM存储引擎\nMyISAM存储引擎不支持事务、表锁设计，但支持`全文索引`，主要面向一些`联机分析处理`（OLAP）数据库应用，它的缓冲池只缓存索引文件，而不缓冲数据文件。\n\n### Memory存储引擎\nMemoery存储引擎（之前称HEAP引擎）将表中的数据存在内存中，如果数据库重启或者发生崩溃，表中的数据都会丢失。它适用于存储临时数据的临时表，以及数据仓库中的维度表。Memory存储引擎默认适用哈希索引，而非B+树索引。\n\nMemory存储索引速度非常快，但只支持表锁，并发性能差，并且不支持TEXT和BLOB列类型；存储varchar类型时按照char的方式进行，浪费内存。\n\n其他存储引擎，比如Archive存储引擎可以提供高速的插入和压缩功能，Maria存储引擎用于取代原有的MyISAM存储引擎等。\n\nMyISAM、InnoDB(1.2)和Sphinx存储引擎都支持全文索引。\n\n\n## 小结\n本章主要从宏观上讲述了MySQL的体系结构，重点介绍了几种应用非常广泛的存储引擎，比如InnoDB、MyISAM、NDB、Memory等。另外还介绍了MySQL的启动和登录，不同平台(系统)在操作上略有不同，但是MySQL数据库确是保持一致的。\n理解数据库和数据库实例的定义与关系，对于学习和使用MySQL都是非常有益的。\n\n\n## 参考资料\n- 《MySQL技术内幕·InnoDB存储引擎》\n\n\n","tags":["读书笔记"]},{"title":"基于Hexo+github创建静态页面博客","url":"/2017/11/05/基于Hexo-github托管静态页面/","content":"## 背景\n之前的博客是动态脚本语言（PHP）搭建在虚拟主机上的Wordpress博客系统。由于已经很久没动PHP了，预期今后都不怎么会再使用PHP，索性就不再维护那套系统。很多内容或者是用MD编写，或者是直接写在公司的wiki上。总而言之，已经没有动力去PHP了。\n\n最近迷上了MD写作，正好Hexo是这样一套框架，能够将MD文档生成美观的响应式页面，因此根据官方文档，搭建了这样一套环境，并将页面托管在了Github，这样还省下了一笔主机费用。\n\n<!-- more -->\n\n### 什么是Hexo\n> [Hexo](https://hexo.io/zh-cn/) 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n## 工具\nGit\n\nNode\n\nHexo框架\n\n## 搭建Hexo构建页面环境\n下面描述的操作均在ubuntu系统下操作，其他环境可能略有不同，如果不能完全理解以下步骤的含义，请自行搜索适用自己平台的软件安装方法。\n1.安装git\n```\nsudo apt-get install -y git\n```\n2.安装Node\n下载 [NodeJs安装包](https://nodejs.org/en/download/) 安装\n或者\n```\nsudo apt-get install -y nodejs npm\n```\n3.下载hexo框架\n```\nnpm install hexo-cli -g\n\n```\n4.生成页面(比如博客)框架, 并启动服务验证\n```\nhexo init blog\ncd blog\nnpm install\nhexo server\n```\n\n更详细的使用说明请移步: [Hexo文档](https://hexo.io/zh-cn/docs/) ,\n[Hexo常用命令](https://hexo.io/zh-cn/docs/commands.html)\n\n## 免费托管到Github\n1.在 Github 上申请一个账户，注意一会系统分配的二级域名就是根据用户名确定的，比如说你的用户名是username，那么最终系统分配的二级域名就是 username.github.io。\n\n2.新建一个用户名开头的仓库（比如 username.github.io），并且将上文生成的页面上传到这个仓库。因为必须要上传了内容，才能使用 Github Pages 服务。\n\n3.进入仓库的设置(Settings)页面，找到  Github Pages 栏目，可以看到已经绑定了master分支，不能修改，但是可以修改展示的主题风格，还可以绑定个性化域名。\n\n4.现在已经可以使用域名进行访问了，如果你的用户名是username，那么可以通过_http://username.github.io_进行访问。当然也可以在仓库的设置页面，开启https访问。\n\n\n## 配置个性化域名\n如果你不满足系统分配的二级域名，其实系统早就给你准备好了，可参考以下步骤为自己托管的页面绑上一个高端、大气、上档次的域名。\n\n1.在仓库的设置页面找到“ Custom domain ”，填入自定义的个性化域名， 比如sense.ink。之后你会发现在仓库的根目录多了一个 CNAME文件，内容就是你刚填写的域名。\n\n2.现在绑定的域名还不能直接访问，需要修改域名的dns解析设置。这个需要在域名注册商提供的管理页面修改，不同的注册商提供的页面不一致，就不细说，主要还是新建一个A记录到二级域名对应的IP地址。如果有问题，可以参考[Github官方官方文档](https://help.github.com/articles/setting-up-an-apex-domain/)。\n\n3.绑定了自定义域名后，会导致默认提供的HTTPS服务不可用（访问时出现一把大红✘可不是友好的用户体验）。\n这个可以通过[ Cloudflare](https://www.cloudflare.com)解决，网上也有人说不可用，反正我试了下是可以的，可以点击[我的博客](https://sense.ink)看看效果。\n\n## 小结\n本次将博客部署到Github，过程简单，没有高深的技术，但确实到思维的模式的变革。从之前的重服务端，到现在的重客户端，结果几乎一致，但成本发生变化：之前使用简单，维护成本高；现在是维护成本低，使用陈本略高，但对于熟悉和热衷MD的码字者来说，可能效率更高。\n\n[总结本来写了一些其他的总结，无奈网易云笔记异常，瞬间没了，初步分析是客户端同步时的bug导致。记录下迁移的过程，方面后续的迁移和改动，也可以为需要的人提供一份实践过的参考文档]\n\n\n","tags":["Hexo"]}]