[{"title":"CORS-跨域请求资源的协议","url":"/2018/06/09/CORS-跨域请求资源协议/","content":"\n当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。\n\n出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS协议请求资源。\n\n# 什么是CORS\n\nCORS（Cross-Origin Resource Sharing 跨源资源共享），当一个请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。\n\n[Web应用安全模型](https://en.wikipedia.org/wiki/Same-origin_policy)，浏览器默认的默认模型，即同源策略，运行在web浏览器下的脚本（如JavaScript），\n可以访问同一个域下的其他页面（资源）下的数据，但是禁止访问其他域下的资源数据。这种限制对于依赖cookie、session等信息的安全认证机制十分重要，减轻跨站信息泄露风险。\n但是随着Web应用的发展，不同域下的资源共享需求越来越大。为了突破同源策略，一种解决方案是[JSONP](https://www.cnblogs.com/JerryTian/p/4194900.html)，可以说是中针对dom加载机制的hack技术，有较大的风险，而CORS是W3C提出的一种解决跨域资源共享的标准化协议，目前主流浏览器都支持该协议。\n\nCORS新增了一组Http首部字段，允许声明哪些源站有权限访问资源，使得跨站数据传输更安全，减少http跨域的风险。\n\n\n# CORS的作用\n\n为了改善网络应用程序，开发人员要求浏览器供应商允许跨域请求。跨域请求主要用于：\n\n- 调用XMLHttpRequest或fetchAPI通过跨站点方式访问资源\n- 网络字体，例如Bootstrap（通过CSS使用@font-face 跨域调用字体）\n- 通过canvas标签，绘制图表和视频\n\n\n# 客户端的处理\n\n## 简单跨域\n当请求同时满足下面两个条件时，浏览器会直接发送GET请求，在同一个请求中做跨域权限的验证。\n\n请求方法是下列之一：\n\n- GET\n- HEAD\n- POST\n\n请求头中的Content-Type请求头的值是下列之一：\n\n- application/x-www-form-urlencoded\n- multipart/form-data\n- text/plain\n\n简单请求时，浏览器会直接发送跨域请求，并在请求头中携带Origin 的header，表明这是一个跨域的请求。服务器端接到请求后，\n会根据自己的跨域规则，通过Access-Control-Allow-Origin和Access-Control-Allow-Methods响应头，来返回验证结果。\n如果验证成功，则会直接返回访问的资源内容。\n\n\n## 预检请求\n与前述简单跨域请求不同，“需预检的请求”要求必须首先使用`OPTIONS`方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。\"预检请求“的使用，\n可以避免跨域请求对服务器的用户数据产生未预期的影响。\n\n\nOPTIONS请求头部中会包含以下头部：`Origin`、`Access-Control-Request-Method`、`Access-Control-Request-Headers`。\n服务器收到`OPTIONS`请求后，设置`Access-Control-Allow-Origin`、`Access-Control-Allow-Methods`、`Access-Control-Allow-Headers`头部与浏览器沟通来判断是否允许这个请求。\n如果Preflighted requests验证通过，浏览器才会发送真正的跨域请求。\n\n\n# CORS增加的首部字段\n\n## Request Header\n\n<pre>\norigin\n</pre>\n\n\nOrigin头在跨域请求或预先请求中，标明发起跨域请求的源域名。\n\n<pre>\nAccess-Control-Request-Method\n</pre>\n\n\n用于表明跨域请求使用的实际HTTP方法\n\n\n<pre>\nAccess-Control-Request-Headers\n</pre>\n\n\n用于在预先请求时，告知服务器要发起的跨域请求中会携带的请求头信息\n\n\n## Response Header\n\n<pre>\nAccess-Control-Allow-Origin\n</pre>\n\n\n\n 服务器端验证后的允许的跨域请求域名，可以是一个具体的域名或是一个*。\n\n<pre>\nAccess-Control-Expose-Headers\n</pre>\n\n\n用于允许返回给跨域请求的响应头列表，在列表中的响应头的内容，才可以被浏览器访问。\n\n<pre>\nAccess-Control-Max-Age\n</pre>\n\n\n用于告知浏览器可以将预先检查请求返回结果缓存的时间，在缓存有效期内，浏览器会使用缓存的预先检查结果判断是否发送跨域请求。\n\n\n<pre>\nAccess-Control-Allow-Credentials\n</pre>\n\n \n用于告知浏览器当withCredentials属性设置为true时，是否可以显示跨域请求返回的内容。简单请求时，浏览器会根据此响应头决定是否显示响应的内容。预先验证请求时，浏览器会根据此响应头决定在发送实际跨域请求时，是否携带认证信息。\n\n<pre>\nAccess-Control-Allow-Methods\n</pre>\n\n 用于告知浏览器可以在实际发送跨域请求时，可以支持的请求方法，可以是一个具体的方法列表或是一个*（表示任意方法）\n\n<pre>\nAccess-Control-Allow-Headers\n</pre>\n\n用于告知浏览器可以在实际发送跨域请求时，可以支持的请求头，可以是一个具体的请求头列表或是一个*（表示任意请求头）\n\n\n# 基于CORS的CSRF攻击\n\nCSRF攻击的大致原理：\n\n+ 用户通过浏览器，访问正常网站A（例如交易平台），通过用户的身份认证（比如用户名/密码）成功；\n+ 网站A产生token等Cookie信息并返回到用户浏览器； \n+ 用户保持A网站页面登录状态的情况下，在同一浏览器中，打开一个新的TAB页访问恶意网站B；\n+ 网站B接收到用户请求后，返回一些攻击性代码，请求A网站的资源（比如发起交易）；\n+ 浏览器执行恶意代码，在用户不知情的情况下携带Cookie信息，向网站A发出请求；\n- 网站A根据用户的Cookie信息核实用户身份（此时用户在A网站是已登录状态），A网站会处理该请求，导致来自网站B的恶意请求被执行；\n\n当然，一般涉及到钱的网站都会有安全审计检查，这种漏洞几乎是不存在的。\n\n\n\n\n# 参考资料\n+ [CORS](https://www.w3.org/TR/cors/)\n+ [enable-cors](https://enable-cors.org/)\n+ [用XMLHTTPRequest来进行ajax异步数据交交互](https://blog.csdn.net/z_l_ming/article/details/54969019)\n- [HTTP访问控制（CORS）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)","tags":["HTTP协议"]},{"title":"MySQL体系结构和存储引擎","url":"/2017/11/08/MySQL体系结构和存储引擎/","content":"## 数据库和实例\n这是两个比较容易混淆的概念：\n\n- 数据库：物理操作系统文件或其他形式文件类型的集合\n- 实例：MySQL数据库有后台线程及一个共享区组成\n\n在MySQL数据库中，这两者的关系通常是一一对应的，即一个数据库对应一个实例，但是在集群情况下，会存在多个实例对应一个数据库的情况。\n\nMySQL是一个被设计为单进程多线程的数据库。MySQL在启动的时候会按一定的顺序查找配置文件， 在存在多份配置文件的时候<!-- more -->，后加载的配置会覆盖先加载的配置；如果没有找到配置文件，则会按照编译时的默认参数设置启动实例。配置搜索顺序可以通过下面的方式查询：\n\n```\ngary@x1:~$ mysql --help | grep my.cnf\n                      order of preference, my.cnf, $MYSQL_TCP_PORT,\n/etc/my.cnf /etc/mysql/my.cnf ~/.my.cnf \n```\n\n## MySQL体系结构\n在学习MySQL体系结构之前，再次辨识下数据库和实例的概念。从概念上说，数据库是文件的概念，是依照某种数据模型组织起来的并存放于二级存储器中的数据集合；数据库实例是程序，是位于用户与操作系统之间的一层数据管理软件，用户对于数据库数据的任何操作，包括数据库定义、数据查询、数据库运行控制等都是在数据实例下进。\n\n![]()\n\n数据库主要由连接池组件、管理和工具组件、SQL接口组件、查询分析器组件、优化器组件、缓冲组件、插件式存储引擎、物理文件。\n\n存储引擎是基于表，而非数据库。\n\n\n## MySQL存储引擎\nMySQL插件式的存储引擎体系结构是它区别于其他数据库的一个重要方面，下面介绍下集中常见的存储引擎。\n\n### InnoDB存储引擎\nInnoDB存储引擎支持事务，设计目标主要面向于`在线事务处理`（OLTP）应用，其主要特点是行锁设计、支持外键。InnoDB存储引擎将数据放在一个逻辑的表空间中，由InnoDB自行管理。从MySQL4.1起，它可以通过一个个独立的ibd文件隔离每个InnoDB存储引擎的表，也支持使用裸设备来建立其表空间。\n\nInnoDB通过`多版本并发控制`(MVCC)来获得高并发行，并且实现了SQL标准的4种`隔离级别`，默认为可重复读(REPEATABLE)。同时使用next-key locking的策略来避免`幻读`现象的产生。\n\nInnoDB存储引擎采用了`聚集`(clustered)的方式来存储表中的数据，每张表的存储都是按主键的顺序进行存放。如果没有显式定义主键，存储引会为每一行生成一个6字节的ROWID，并以此为主键。\n\n\n### MyISAM存储引擎\nMyISAM存储引擎不支持事务、表锁设计，但支持`全文索引`，主要面向一些`联机分析处理`（OLAP）数据库应用，它的缓冲池只缓存索引文件，而不缓冲数据文件。\n\n### Memory存储引擎\nMemoery存储引擎（之前称HEAP引擎）将表中的数据存在内存中，如果数据库重启或者发生崩溃，表中的数据都会丢失。它适用于存储临时数据的临时表，以及数据仓库中的维度表。Memory存储引擎默认适用哈希索引，而非B+树索引。\n\nMemory存储索引速度非常快，但只支持表锁，并发性能差，并且不支持TEXT和BLOB列类型；存储varchar类型时按照char的方式进行，浪费内存。\n\n其他存储引擎，比如Archive存储引擎可以提供高速的插入和压缩功能，Maria存储引擎用于取代原有的MyISAM存储引擎等。\n\nMyISAM、InnoDB(1.2)和Sphinx存储引擎都支持全文索引。\n\n\n## 小结\n本章主要从宏观上讲述了MySQL的体系结构，重点介绍了几种应用非常广泛的存储引擎，比如InnoDB、MyISAM、NDB、Memory等。另外还介绍了MySQL的启动和登录，不同平台(系统)在操作上略有不同，但是MySQL数据库确是保持一致的。\n理解数据库和数据库实例的定义与关系，对于学习和使用MySQL都是非常有益的。\n\n\n## 参考资料\n- 《MySQL技术内幕·InnoDB存储引擎》\n\n\n","tags":["读书笔记"]},{"title":"基于Hexo+github创建静态页面博客","url":"/2017/11/05/基于Hexo-github托管静态页面/","content":"## 背景\n之前的博客是动态脚本语言（PHP）搭建在虚拟主机上的Wordpress博客系统。由于已经很久没动PHP了，预期今后都不怎么会再使用PHP，索性就不再维护那套系统。很多内容或者是用MD编写，或者是直接写在公司的wiki上。总而言之，已经没有动力去PHP了。\n\n最近迷上了MD写作，正好Hexo是这样一套框架，能够将MD文档生成美观的响应式页面，因此根据官方文档，搭建了这样一套环境，并将页面托管在了Github，这样还省下了一笔主机费用。\n\n<!-- more -->\n\n### 什么是Hexo\n> [Hexo](https://hexo.io/zh-cn/) 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n## 工具\nGit\n\nNode\n\nHexo框架\n\n## 搭建Hexo构建页面环境\n下面描述的操作均在ubuntu系统下操作，其他环境可能略有不同，如果不能完全理解以下步骤的含义，请自行搜索适用自己平台的软件安装方法。\n1.安装git\n```\nsudo apt-get install -y git\n```\n2.安装Node\n下载 [NodeJs安装包](https://nodejs.org/en/download/) 安装\n或者\n```\nsudo apt-get install -y nodejs npm\n```\n3.下载hexo框架\n```\nnpm install hexo-cli -g\n\n```\n4.生成页面(比如博客)框架, 并启动服务验证\n```\nhexo init blog\ncd blog\nnpm install\nhexo server\n```\n\n更详细的使用说明请移步: [Hexo文档](https://hexo.io/zh-cn/docs/) ,\n[Hexo常用命令](https://hexo.io/zh-cn/docs/commands.html)\n\n## 免费托管到Github\n1.在 Github 上申请一个账户，注意一会系统分配的二级域名就是根据用户名确定的，比如说你的用户名是username，那么最终系统分配的二级域名就是 username.github.io。\n\n2.新建一个用户名开头的仓库（比如 username.github.io），并且将上文生成的页面上传到这个仓库。因为必须要上传了内容，才能使用 Github Pages 服务。\n\n3.进入仓库的设置(Settings)页面，找到  Github Pages 栏目，可以看到已经绑定了master分支，不能修改，但是可以修改展示的主题风格，还可以绑定个性化域名。\n\n4.现在已经可以使用域名进行访问了，如果你的用户名是username，那么可以通过_http://username.github.io_进行访问。当然也可以在仓库的设置页面，开启https访问。\n\n\n## 配置个性化域名\n如果你不满足系统分配的二级域名，其实系统早就给你准备好了，可参考以下步骤为自己托管的页面绑上一个高端、大气、上档次的域名。\n\n1.在仓库的设置页面找到“ Custom domain ”，填入自定义的个性化域名， 比如sense.ink。之后你会发现在仓库的根目录多了一个 CNAME文件，内容就是你刚填写的域名。\n\n2.现在绑定的域名还不能直接访问，需要修改域名的dns解析设置。这个需要在域名注册商提供的管理页面修改，不同的注册商提供的页面不一致，就不细说，主要还是新建一个A记录到二级域名对应的IP地址。如果有问题，可以参考[Github官方官方文档](https://help.github.com/articles/setting-up-an-apex-domain/)。\n\n3.绑定了自定义域名后，会导致默认提供的HTTPS服务不可用（访问时出现一把大红✘可不是友好的用户体验）。\n这个可以通过[ Cloudflare](https://www.cloudflare.com)解决，网上也有人说不可用，反正我试了下是可以的，可以点击[我的博客](https://sense.ink)看看效果。\n\n## 小结\n本次将博客部署到Github，过程简单，没有高深的技术，但确实到思维的模式的变革。从之前的重服务端，到现在的重客户端，结果几乎一致，但成本发生变化：之前使用简单，维护成本高；现在是维护成本低，使用陈本略高，但对于熟悉和热衷MD的码字者来说，可能效率更高。\n\n[总结本来写了一些其他的总结，无奈网易云笔记异常，瞬间没了，初步分析是客户端同步时的bug导致。记录下迁移的过程，方面后续的迁移和改动，也可以为需要的人提供一份实践过的参考文档]\n\n\n","tags":["Hexo"]}]